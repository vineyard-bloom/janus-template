"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const json_schema_to_typescript_1 = require("json-schema-to-typescript");
function parseJson2Ts(jsonSchema, typeName, extendsFrom, embeddedWithin) {
    return __awaiter(this, void 0, void 0, function* () {
        let writeableTypeString = (yield json_schema_to_typescript_1.compile(jsonSchema, typeName)).replace(exports.jsonSchema2TsAutoGeneratedText, "");
        if (extendsFrom) {
            writeableTypeString = appendInterfaceExtension(writeableTypeString, extendsFrom);
        }
        if (embeddedWithin) {
            writeableTypeString = nestContentIntoProperty(writeableTypeString, embeddedWithin);
        }
        return writeableTypeString;
    });
}
exports.parseJson2Ts = parseJson2Ts;
function appendInterfaceExtension(typeDef, interfaceName) {
    const typeDefChars = typeDef.split("");
    const definitionBeginning = typeDefChars.findIndex(word => word === "{");
    typeDefChars.splice(definitionBeginning, 0, `extends ${interfaceName} `);
    return typeDefChars.join("");
}
function nestContentIntoProperty(typeDef, propertyName) {
    const typeDefWords = typeDef.split(" ");
    const indentedTypeDef = typeDefWords.map(word => word.replace("\n", "\n\t")).join(" ");
    const typeDefChars = indentedTypeDef.split("");
    const definitionBeginning = typeDefChars.findIndex(word => word === "{");
    typeDefChars.splice(definitionBeginning + 1, 0, `\n\t${propertyName}: {`);
    const definitionEnding = typeDefChars.reverse().findIndex(word => word === "}");
    typeDefChars.splice(definitionEnding + 1, 0, `}\n`);
    typeDefChars.reverse();
    return typeDefChars.join("");
}
exports.jsonSchema2TsAutoGeneratedText = "/**\n" +
    " * This file was automatically generated by json-schema-to-typescript.\n" +
    " * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,\n" +
    " * and run json-schema-to-typescript to regenerate this file.\n" +
    " */";
//# sourceMappingURL=json-schema-to-typescript-formatter.js.map